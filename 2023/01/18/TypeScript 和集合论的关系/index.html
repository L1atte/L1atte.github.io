<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteIcon/favicon_package/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteIcon/favicon_package/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteIcon/favicon_package/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"l1atte.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="本文是《TypeScript and Set Theory》的中文翻译，原文链接：https:&#x2F;&#x2F;ivov.dev&#x2F;notes&#x2F;typescript-and-set-theory"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 和集合理论的关系"><meta property="og:url" content="https://l1atte.github.io/2023/01/18/TypeScript%20%E5%92%8C%E9%9B%86%E5%90%88%E8%AE%BA%E7%9A%84%E5%85%B3%E7%B3%BB/index.html"><meta property="og:site_name" content="Latte&#39;s Blog"><meta property="og:description" content="本文是《TypeScript and Set Theory》的中文翻译，原文链接：https:&#x2F;&#x2F;ivov.dev&#x2F;notes&#x2F;typescript-and-set-theory"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ivov.dev/posts/set-theory/types-as-infinite-sets.png"><meta property="og:image" content="https://ivov.dev/posts/set-theory/types-as-finite-sets.png"><meta property="og:image" content="https://ivov.dev/posts/set-theory/set-operations.png"><meta property="article:published_time" content="2023-01-17T16:00:00.000Z"><meta property="article:modified_time" content="2023-01-17T16:00:00.000Z"><meta property="article:author" content="Latte"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ivov.dev/posts/set-theory/types-as-infinite-sets.png"><link rel="canonical" href="https://l1atte.github.io/2023/01/18/TypeScript%20%E5%92%8C%E9%9B%86%E5%90%88%E8%AE%BA%E7%9A%84%E5%85%B3%E7%B3%BB/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://l1atte.github.io/2023/01/18/TypeScript%20%E5%92%8C%E9%9B%86%E5%90%88%E8%AE%BA%E7%9A%84%E5%85%B3%E7%B3%BB/","path":"2023/01/18/TypeScript 和集合论的关系/","title":"TypeScript 和集合理论的关系"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>TypeScript 和集合理论的关系 | Latte's Blog</title><script async defer data-website-id="" src=""></script><script defer data-domain="" src=""></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Latte's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">FrontEnd Developer</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TypeScript-%E5%92%8C%E9%9B%86%E5%90%88%E7%90%86%E8%AE%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">TypeScript 和集合理论的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E7%B1%BB%E5%9E%8B%E8%A7%86%E4%BD%9C%E9%9B%86%E5%90%88"><span class="nav-number">1.1.</span> <span class="nav-text">将类型视作集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part1-%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">Part1: 赋值兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-never-%E8%B5%8B%E5%80%BC%E6%98%AF%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">使用 never 赋值是不合理的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#any-%E8%A2%AB%E8%A7%86%E4%BD%9C%E9%80%83%E9%80%B8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">any 被视作逃逸类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.1.</span><span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part2-%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">Part2: 创建类型</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Latte" src="/img/taylor.jpg"><p class="site-author-name" itemprop="name">Latte</p><div class="site-description" itemprop="description">Warm smell of colitis</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/L1atte" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;L1atte" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:l4atte@gmail.com" title="E-Mail → mailto:l4atte@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://l1atte.github.io/2023/01/18/TypeScript%20%E5%92%8C%E9%9B%86%E5%90%88%E8%AE%BA%E7%9A%84%E5%85%B3%E7%B3%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/taylor.jpg"><meta itemprop="name" content="Latte"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Latte's Blog"><meta itemprop="description" content="Warm smell of colitis"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="TypeScript 和集合理论的关系 | Latte's Blog"><meta itemprop="description" content="本文是《TypeScript and Set Theory》的中文翻译，原文链接：https://ivov.dev/notes/typescript-and-set-theory"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">TypeScript 和集合理论的关系</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-18T00:00:00+08:00">2023-01-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/TypeScript/" itemprop="url" rel="index"><span itemprop="name">TypeScript</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div><div class="post-description">本文是《TypeScript and Set Theory》的中文翻译，原文链接：https://ivov.dev/notes/typescript-and-set-theory</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="TypeScript-和集合理论的关系"><a href="#TypeScript-和集合理论的关系" class="headerlink" title="TypeScript 和集合理论的关系"></a>TypeScript 和集合理论的关系</h1><blockquote><p>本文是 <strong>TypeScript and Set Theory</strong> 的中文翻译，原文链接：<a target="_blank" rel="noopener" href="https://ivov.dev/notes/typescript-and-set-theory">https://ivov.dev/notes/typescript-and-set-theory</a></p></blockquote><h2 id="将类型视作集合"><a href="#将类型视作集合" class="headerlink" title="将类型视作集合"></a>将类型视作集合</h2><p>​ 首先我们知道 TypeScript 是具有<strong>类型语法</strong>的 JavaScript ，我们在学习 TypeScript 的时候，会遇到诸如 <code>extends</code>, <code>&amp;</code>, <code>|</code>, <code>unknown</code>, <code>never</code> 等一些概念。通常我们会孤立的理解他们。</p><p>​ 但是，集合论提供了一个心智模型，现在让我们将类型视作为一个可能值的集合，即一个类型的每个值都可以被认为是一个集合中的元素，这使得一个类型可以与一个集合相比较，根据集合的定义，其元素属于这个集合。</p><p>​ 想象一下</p><ul><li><code>number</code> 类型是每个可能数字的无限集合</li><li><code>string</code> 类型是每个可能字符串的无限集合</li><li><code>object</code> 类型是每个可能对象的无限集合，JavaScript 中，对象包括 function, array, date 等等</li></ul><img src="https://ivov.dev/posts/set-theory/types-as-infinite-sets.png" alt="Types as infinite sets" style="zoom:80%"><p>​ 不是所有的被视作集合的类型都是无限的，比如 <code>undefined</code>, <code>null</code>, 和 <code>boolean</code> 类型，它们都是有限元素的集合</p><p>​ 想象一下</p><ul><li><code>undefined</code> 类型是一个只有 <code>undefined</code> 元素的集合</li><li><code>null</code> 类型是一个只有 <code>null</code> 元素的集合</li><li><code>boolean</code> 类型是一个只有 <code>true</code> 和 <code>false</code> 元素的集合</li></ul><p><img src="https://ivov.dev/posts/set-theory/types-as-finite-sets.png" alt="Types as finite sets"></p><p>​ 还有别的有限元素的集合，比如：字面量字符串和字面量字符串的联合类型。下面第一个是包含用户指定的字面量字符串的集合，第二个是包含少量用户指定的字面量字符串的集合。这些都是 <code>string</code> 类型的子集</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// both true, string literal ⊂ string</span></span><br><span class="line"><span class="keyword">type</span> W = <span class="string">&#x27;a&#x27;</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> X = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true, string literal ⊆ same string literal</span></span><br><span class="line"><span class="keyword">type</span> Y = <span class="string">&#x27;a&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;a&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true, string ⊆ string</span></span><br><span class="line"><span class="keyword">type</span> Z = <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>​ 注意，条件类型中的 <code>extends</code> 相当于</p><ul><li>⊂：真子集</li><li>⊆：子集</li></ul><p>​ 这在泛型约束中也是如此</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constraint: T ⊂ string or T ⊆ string</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> myFunc&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">arg</span>: T): T[];</span><br></pre></td></tr></table></figure><p>​ 在接口声明中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true, Person ⊂ object</span></span><br><span class="line"><span class="keyword">type</span> Q = <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="built_in">object</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true, Employee ⊂ Person</span></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>​ 由于 <code>object</code> 类型是任何可能对象的集合，而 <code>interface</code> 是与其属性（properties）匹配的对象的集合，任何给定的 <code>interface</code> 都是 <code>object</code> 的真子集</p><p>​ 而反过来，当一个子接口 <code>extends</code> 一个父接口，子接口是与父接口属性匹配的所有可能性的集合。因此，子接口是父接口的真子集，而父接口本身也是 <code>object</code> 类型的真子集</p><p>​ 同样注意到，如果一个类型是另一个类型的真子集，那么也暗示了它们在赋值上的兼容性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myString</span>: <span class="built_in">string</span> = <span class="string">&#x27;myString&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStringLiteral</span>: <span class="string">&#x27;only&#x27;</span> | <span class="string">&#x27;specific&#x27;</span> | <span class="string">&#x27;strings&#x27;</span> = <span class="string">&#x27;only&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// both assignable, string ⊂ string, string literal ⊂ string</span></span><br><span class="line">myString = <span class="string">&#x27;myNewString&#x27;</span>;</span><br><span class="line">myString = myStringLiteral;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not assignable, string ⊄ string literal</span></span><br><span class="line">myStringLiteral = myString;</span><br></pre></td></tr></table></figure><p>​ 这些和其他编译行为都可以用集合理论来解释</p><p>​ 将类型视作集合可以帮助我们进行以下推理：</p><ol><li>在赋值时的类型兼容性</li><li>通过类型操作符创建类型</li><li>解析条件类型</li></ol><h2 id="Part1-赋值兼容性"><a href="#Part1-赋值兼容性" class="headerlink" title="Part1: 赋值兼容性"></a>Part1: 赋值兼容性</h2><p>​ 赋值将一个值存储在标有变量的特定内存位置，值和变量都是类型化的，因为赋值兼容性取决于两个因素：值的类型和变量的类型</p><p>​ 当两种类型是相同的时候，就可以进行赋值了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// succeeds, number is assignable to number</span></span><br></pre></td></tr></table></figure><p>​ 但是当两个类型不完全相同的时候，为了使赋值成功，必须发生类型转换。当我们把一个类型的值赋值给一个不同类型的变量时，会发生类型转换，也就是说，我们令值的类型成为变量的类型</p><p>​ 类型转换通常采取向下兼容的形式：我们将一个类型的子集赋值给匹配这个类型的变量，比如：我们将字面量字符串赋值给 <code>string</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myString</span>: <span class="built_in">string</span> = <span class="string">&#x27;myString&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStringLiteral</span>: <span class="string">&#x27;only&#x27;</span> | <span class="string">&#x27;specific&#x27;</span> | <span class="string">&#x27;strings&#x27;</span> = <span class="string">&#x27;only&#x27;</span>;</span><br><span class="line"></span><br><span class="line">myString = myStringLiteral; <span class="comment">// upcasting succeeds, assignable</span></span><br></pre></td></tr></table></figure><p>​ 将一个子类型向上转化为一个父类型，也就是说，一个子集赋值给一个父集。TypeScript允许这种转换，因为它是类型安全的：如果一个集合是另一个集合的子集，那么小集合中的任何元素也是大集合中的成员。</p><p>​ 另一方面，降级通常是不允许的。为了确保类型安全，我们不能声明一个大集合的成员也是一个小集合的成员–我们无法确定这一点。而如果两个集合都是相等的，那么这两个类型是相同的，所以不需要进行类型转换。</p><p>​ 把上面的赋值反过来，就可以看出，把 <code>string</code> 类型赋值给字面量字符串是不允许的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myString</span>: <span class="built_in">string</span> = <span class="string">&#x27;myString&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStringLiteral</span>: <span class="string">&#x27;only&#x27;</span> | <span class="string">&#x27;specific&#x27;</span> | <span class="string">&#x27;strings&#x27;</span> = <span class="string">&#x27;only&#x27;</span>;</span><br><span class="line"></span><br><span class="line">myStringLiteral = myString; <span class="comment">// downcasting fails, not assignable</span></span><br></pre></td></tr></table></figure><p>​ 按照这个逻辑，我们知道在赋值过程中哪些类型转换是被允许的，但是有两种情况除外</p><p>​ 从赋值兼容性来讲，<code>never</code> 是特殊的情况：</p><ul><li><code>never</code> 可以被赋值到任何类型</li><li>没有一种类型可以被赋值到 <code>never</code></li></ul><p>​ 这意味着任何类型都可以最终接收 <code>never</code>，但是 <code>never</code> 不能接收任何类型。换句话说，任何类型都可以向下兼容 <code>never</code>，但是 <code>never</code> 不能向下兼容任何一个类型。<code>nerver</code> 因此被称为 <code>bottom type</code></p><p>​ 在集合理论中，<code>never</code>是没有任何元素的集合，也没有任何子集——<code>never</code> 是空集</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">never</span> = <span class="number">1</span>; <span class="comment">// downcasting fails, not assignable</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="使用-never-赋值是不合理的"><a href="#使用-never-赋值是不合理的" class="headerlink" title="使用 never 赋值是不合理的"></a>使用 <code>never</code> 赋值是不合理的</h4><p>尽管 <code>never</code> 是所有集合的子集，但是在实践中，没有将 <code>never</code> 赋值给另一个类型的例子。因为根据定义，<code>never</code> 类型的值是不存在的——没有一个真正存在的值，它的类型是 <code>never</code></p><p>但是，如果实践中 <code>never</code> 类型的值是不能赋值的，那么 <code>never</code> 可以被赋值到另一个类型是什么意思？请参考这个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53540282/why-is-never-assignable-to-every-type/53748099#53748099">答案</a></p></blockquote><p>​ 与之相反的是 <code>unknown</code>，多数用于标记一个值，其类型需要在使用前被确认。比如：<code>JSON.parse()</code> 最好应该返回 <code>unknown</code> 。TypeScript 强制 <code>unknows</code> 类型的值需要在使用前确认类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toUpperCase</span>(); <span class="comment">// still unknown, disallowed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  a.<span class="title function_">toUpperCase</span>(); <span class="comment">// narrowed to string, allowed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 赋值兼容性方面，<code>unknown</code> 有特殊的一面：</p><ul><li>任何类型都可以被赋值到 <code>unknown</code></li><li><code>unknown</code> 不可以被赋值给任何类型</li></ul><p>有趣的是，刚好与前面的 <code>never</code> 相反</p><p>​ <code>unknown</code> 可以接收任何类型，但是没有类型可以接收 <code>unknown</code>。换句话说，<code>unknown</code> 可以向下兼容任何类型，但没有类型可以向下兼容 <code>unknown</code></p><p>​ 由于 <code>unknown</code> 需要在使用前确认类型，<code>unknown</code> 可能是任何类型，每个类型就像在 <code>unknown</code> 的保护伞之下。因此 <code>unknown</code> 被称之为 <code>top-type</code></p><blockquote><h4 id="any-被视作逃逸类型"><a href="#any-被视作逃逸类型" class="headerlink" title="any 被视作逃逸类型"></a><code>any</code> 被视作逃逸类型</h4><p>奇怪的是，<code>any</code> 像是 <code>unknown</code> 和 <code>never</code> 的结合体。任何类型都可以被赋值给 <code>any</code> ，同样 <code>any</code> 也可以被赋值给任何类型。作为两种特殊规则的混合体，<code>any</code>在集合论中没有等价物，所以最好把<code>any</code>视作为逃逸类型（不受 TypeScript 约束）</p></blockquote><h3><a href="#" class="headerlink"></a></h3><h2 id="Part2-创建类型"><a href="#Part2-创建类型" class="headerlink" title="Part2: 创建类型"></a>Part2: 创建类型</h2><p>​ 我们可以使用集合运算符来将现有的集合组合成一个新的集合</p><ul><li>A、B 的并集表示至少在 A 或 B 中所有元素的集合</li><li>A、B 的交集表示同时在 A 和 B 中所有元素的集合</li><li>A、B 的差集表示所有在 A 中但是不是 B 的元素的集合</li><li>A 的反集表示全集 U 中不在 A 的所有元素的集合</li></ul><p>用图像描述</p><img src="https://ivov.dev/posts/set-theory/set-operations.png" alt="Set of relations" style="zoom:50%"><p>在这四个集合运算符中，TypeScript 实现了两个作为类型运算符</p><ul><li><code>|</code> 用于并集</li><li><code>&amp;</code> 用于交集</li></ul><p>与 <code>|</code> 联合意味着创建一个由两种输入类型组成的更广泛、更具包容性的类型</p><p>与 <code>&amp;</code> 相交意味着创建一个由两种输入类型共享的元素组成的更小、更具局限性的类型</p><p>作为类型操作符，<code>|</code> 和 <code>&amp;</code>操作的是类型（集合） ，而不是属于这些集合的元素（值）。可以将类型操作符看作是接受类型作为参数，并返回另一种类型作为输出的函数</p><p>当操作基本类型的时候，<code>|</code>和<code>&amp;</code>的行为是可预测的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// string | number → both string and number are admissible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringAndNumber</span> = <span class="built_in">string</span> &amp; <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// never → no type is ever admissible</span></span><br></pre></td></tr></table></figure><p>但是操作 <code>interface</code> 的时候，<code>|</code>和<code>&amp;</code>似乎是反直觉的。</p><p>思考下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result = keyof (<span class="title class_">Foo</span> | <span class="title class_">Bar</span>) <span class="comment">// &quot;name&quot;</span></span><br></pre></td></tr></table></figure><p>联合类型 <code>|</code>通常被认为是指“ A 或 B 是可以接受的”，这与布尔运算符 <code>||</code> 在表达式中表示 <code>OR</code> 的事实大致吻合。然而，从 <code>OR</code> 的角度来考虑接口的联合，可能会产生误导</p><p>将联合类型 <code>Foo | Bar</code>解析为允许<code>Foo</code>或者<code>Bar</code>的方法是错误的。如上所示，联合类型 <code>Foo | Bar</code>将输出一个 <code>Foo</code> 和 <code>Bar</code> 共同拥有的方法的集合。</p><p>反之，对于相交类型也是如此： <code>&amp;</code> 通常被认为“A 和 B”，这与布尔运算符 <code>&amp;&amp;</code> 在表达式中表示 <code>AND</code> 的事实大致吻合。然是，从 <code>AND</code> 的角度来考虑接口的联合，可能会产生误导</p><p>思考下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> resule = keyof (<span class="title class_">Foo</span> &amp; <span class="title class_">Bar</span>) <span class="comment">// &quot;name&quot; | &quot;age&quot; | &quot;gender&quot;</span></span><br></pre></td></tr></table></figure><p>将相交类型 <code>Foo &amp; Bar</code> 解析为允许 <code>Foo</code> 和 <code>Bar</code> 的方法是错误的，如上所示，相交类型<code>Foo &amp; Bar</code>会输出他们的所有元素组成的集合。</p><p><u><strong>总而言之，在联合类型中，用<code>OR</code>的思维方式可能会产生误导，而用更广泛的输出集的方式有助于理解；在相交类型中，用<code>AND</code>的思维方式也会误导，而用较窄的输出集会有助于理解</strong></u></p><p>但是，为什么在联合类型和相交类型中，我们的期望被颠覆了？</p><p>对象类型是所有可能性的无限集合；一个接口是具有特定属性的集合。那么，接口就是对象的一个子集，在所有可能性的无限集合中，那些与属性相匹配的对象可以被分配给它</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">object</span>;</span><br><span class="line">a = &#123; <span class="attr">z</span>: <span class="number">1</span> &#125;; <span class="comment">// &#123; z: number &#125; is assignable to object</span></span><br></pre></td></tr></table></figure><p>由于接口描述了一个对象的具体属性，我们给接口添加的属性越多，匹配的对象就越少，所以对应的集合也越小。向接口添加属性会缩小它代表的集合，反之亦然。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">isMarried</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当联合两个接口的时候，我们要创建一个输出类型，接受与之匹配的类型：</p><ul><li>一个输入类型，或者</li><li>另一个输入类型，或者</li><li>它们共同拥有的类型</li></ul><p>从所有可能性的集合中，这三种类型被分配到输出类型中，使得输出类型比两个输入类型更广泛，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: A | B = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// succeeds</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>: A | B = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;; <span class="comment">// succeeds</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>: A | B = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;; <span class="comment">// succeeds, assignable to overlap</span></span><br></pre></td></tr></table></figure><p>对于基础类型的联合类型，如 <code>string | number</code> 也会产生重叠，但是没有同时属于两种类型的基础类型，所以没有东西可以被分配给它们重叠的部分。因此我们倾向于忽略这种情况。导致我们默认用布尔操作符 <code>OR</code> 来思考联合类型，但这在对象类型中是错误的！</p><p>反过来说，当 <code>interface</code> 相交时，要输出两个 <code>interface</code> 的重叠部分。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: A &amp; B = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// fails</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>: A &amp; B = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;; <span class="comment">// fails</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>: A &amp; B = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;; <span class="comment">// succeeds</span></span><br></pre></td></tr></table></figure><p>对于基础类型的相交类型，如 <code>string | number</code> 永远是空集 <code>never</code>。因为没有基础类型可以与另一个基础类型共享元素。但是接口是对象的子集所以接口的相交类型总是可以产生一个同时满足两个输入的接口。即使相交的接口没有共同属性。</p><p>而且，我们将对基础类型的相交的直觉带到了非基础类型上，会导致我们用布尔操作符 <code>AND</code> 来思考。导致我们错误的认为上面 <code>x</code> 和 <code>y</code> 应该成功，而实际上它们不成功</p><blockquote><p><strong>累计效应</strong></p><p>当我们联合两个接口，它们重叠部分将会累计属性；</p><p>当我们将不同的接口相交时，输出类型会累计属性；</p><p>当我们用接口继承另一个接口时，子接口会累计属性。</p><p>在所有这三种情况下，这种累积效应类似于接口声明的合并，即同一接口的单独声明创造了一个聚合接口，累积了每个接口中的属性。</p><p><strong>Cumulative effect</strong></p><p>When we unionize different interfaces, the overlap accumulates properties. When we intersect different interfaces, the output type accumulates properties. When we declare that an interface <code>extends</code> another, the child interface accumulates properties.</p><p>In all three cases, this cumulative effect resembles that of <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">interface declaration merging</a>, where separate declarations of the same interface create an aggregate interface that accumulates the properties in each.</p></blockquote></div><footer class="post-footer"><div class="post-tags"><a href="/tags/TypeScript/" rel="tag"># TypeScript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20ES6%20%E7%9A%84%20Class%20%E5%92%8C%20extends%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="深入理解 ES6 的 Class 和 extends 底层实现原理"><i class="fa fa-chevron-left"></i> 深入理解 ES6 的 Class 和 extends 底层实现原理</a></div><div class="post-nav-item"></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Latte</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://l1atte.github.io/2023/01/18/TypeScript%20%E5%92%8C%E9%9B%86%E5%90%88%E8%AE%BA%E7%9A%84%E5%85%B3%E7%B3%BB/"}</script><script src="/js/third-party/quicklink.js"></script></body></html>