<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteIcon/favicon_package/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteIcon/favicon_package/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteIcon/favicon_package/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"l1atte.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"width":300},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="从零实现简易的 React"><meta property="og:type" content="article"><meta property="og:title" content="Build your own React"><meta property="og:url" content="https://l1atte.github.io/2023/02/15/Build%20your%20own%20React/index.html"><meta property="og:site_name" content="Latte&#39;s Blog"><meta property="og:description" content="从零实现简易的 React"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-02-14T16:00:00.000Z"><meta property="article:modified_time" content="2023-02-14T16:00:00.000Z"><meta property="article:author" content="Latte"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://l1atte.github.io/2023/02/15/Build%20your%20own%20React/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://l1atte.github.io/2023/02/15/Build%20your%20own%20React/","path":"2023/02/15/Build your own React/","title":"Build your own React"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Build your own React | Latte's Blog</title><script async defer data-website-id="" src=""></script><script defer data-domain="" src=""></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Latte's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">FrontEnd Developer</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84-React"><span class="nav-number">1.</span> <span class="nav-text">从零实现简易的 React</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-createElementFunction"><span class="nav-number">1.1.</span> <span class="nav-text">The createElementFunction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-render-Function"><span class="nav-number">1.2.</span> <span class="nav-text">The render Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrent-Mode"><span class="nav-number">1.3.</span> <span class="nav-text">Concurrent Mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fibers"><span class="nav-number">1.4.</span> <span class="nav-text">Fibers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Render-and-Commit-Phases"><span class="nav-number">1.5.</span> <span class="nav-text">Render and Commit Phases</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reconciliation"><span class="nav-number">1.6.</span> <span class="nav-text">Reconciliation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-Components"><span class="nav-number">1.7.</span> <span class="nav-text">Function Components</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Latte" src="/img/taylor.jpg"><p class="site-author-name" itemprop="name">Latte</p><div class="site-description" itemprop="description">Warm smell of colitis</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/L1atte" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;L1atte" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:l4atte@gmail.com" title="E-Mail → mailto:l4atte@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://l1atte.github.io/2023/02/15/Build%20your%20own%20React/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/taylor.jpg"><meta itemprop="name" content="Latte"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Latte's Blog"><meta itemprop="description" content="Warm smell of colitis"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Build your own React | Latte's Blog"><meta itemprop="description" content="从零实现简易的 React"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Build your own React</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-02-15T00:00:00+08:00">2023-02-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div><div class="post-description">从零实现简易的 React</div></div></header><div class="post-body" itemprop="articleBody"><p>递归调用 render 渲染节点的缺点：一旦开始 render，直到结束前我们都没有方法中断渲染。当节点树很大的时候，我们可能需要等待很长时间</p><p>所以我们将整个工作分成一个个小的工作单元，当我们完成小工作单元并且没有其他要做的事情时，我们会让出线程给浏览器渲染。因此，我们使用一个新的数据结构 fiber，一个 fiber 意味着一个 dom 节点，也意味着一个小的工作单元</p><p>我们在 render 方法里面定义 rootFiber，并将其设置为 <code>nextUnitOfWork</code>，后续在<code>performUnitOfWork</code>方法中获取工作单元</p><p>每个 fiber 会做三件事</p><ol><li>将元素添加进 dom</li><li>为当前 fiber 的 children 创建 fiber</li><li>选择下一个工作单元</li></ol><p>fiber 结构的好处是很轻松地找到下一个工作单元（具有 parent、children、sibling 节点引用）</p><p>当我们完成一个 fiber 的工作时，我们会按照以下优先级选择下一个 fiber</p><ul><li>在当前节点下寻找是否有子节点<ul><li>若有, 则进入子节点</li><li>若没有, 则在当前节点下寻找是否有下一个相邻节点<ul><li>若有, 则进入下一个相邻节点</li><li>若没有, 则返回它的父节点</li></ul></li></ul></li></ul><p>当我们一直遍历到 rootFiber，意味着 <code>render</code>方法结束了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nextUnitOfWork = &#123;</span><br><span class="line">  <span class="attr">dom</span>: container,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [element],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">  dom,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    children,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">  fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fiber.<span class="property">parent</span>) &#123;</span><br><span class="line">  fiber.<span class="property">parent</span>.<span class="property">dom</span>.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从零实现简易的-React"><a href="#从零实现简易的-React" class="headerlink" title="从零实现简易的 React"></a>从零实现简易的 React</h1><h2 id="The-createElementFunction"><a href="#The-createElementFunction" class="headerlink" title="The createElementFunction"></a>The <code>createElement</code>Function</h2><p>通常，我们在 React 中使用 JSX 定义组件。这实际上会被 babel 转译成调用 <code>React.createElement( )</code>的形式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><code>React.createElement( )</code>会从其参数创建一个对象，所以我们可以直接写成</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  <span class="string">&quot;Hello&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// React.createElement( )返回的结果：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.createElement( )</code>返回一个具有<code>type</code>和<code>props</code>字段的对象</p><p><code>type</code>是一个字符串，制定我们要创建的 DOM 节点的类型，被用于传递给 <code>document.createElement</code>创建 HTML 元素，它也可以是一个函数，我们会在 xxx 提到</p><p><code>props</code>是一个对象，它有所有来自 <code>JSX</code>属性的键和值。同时，它还有一个特殊的属性：<code>children</code></p><p>我们手动实现一下<code>React.createElement</code>，通过对<code>props</code>使用展开操作符、对<code>children</code>使用剩余参数，使得<code>children</code>始终为数组,当<code>children</code>包含基础类型的时候，我们为其指定一个特殊类型<code>TEXT_ELEMENT</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, props, ...children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : <span class="title function_">createTextElement</span>(child);</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextElement</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextElement</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，<code>createElement(&#39;div&#39;)</code>会 return</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElement(&quot;div&quot;, null, a, b)</code>会 return</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [a, b] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>React 没有包裹原始值，也没有在没有孩子的时候创建空数组，但我们这样做是因为它会简化我们的代码，对于我们的库来说，我们更喜欢简单的代码，而不是性能好的代码。</p></blockquote><h2 id="The-render-Function"><a href="#The-render-Function" class="headerlink" title="The render Function"></a>The <code>render</code> Function</h2><p>我们来实现下<code>React.render()</code>，首先，我们只关心如何向<code>DOM</code>添加东西，后续再处理更新和删除</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据 type 创建 dom</span></span><br><span class="line">  <span class="keyword">const</span> dom = element.<span class="property">type</span> == <span class="string">&quot;TEXT_ELEMENT&quot;</span> ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>) : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(element.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 分配给 dom</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt; key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(element.<span class="property">props</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.<span class="property">props</span>[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归处理 children</span></span><br><span class="line">  element.<span class="property">props</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">render</span>(child, dom));</span><br><span class="line">  <span class="comment">// 将 dom 插入 container</span></span><br><span class="line">  container.<span class="title function_">appendChild</span>(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们根据元素的<code>type</code>创建一个<code>dom</code>，然后将<code>props</code>分配给<code>dom</code>，最后递归处理元素的<code>children</code>，</p><h2 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h2><p>但是，我们需要重构一下之前的代码</p><p>问题出在递归调用<code>render</code>上</p><p>一旦我们开始渲染，将无法阻止渲染一<code>dom</code>树。而且，如果这棵树很大，将会长期阻塞主线程。如果浏览器需要做一些高优先级的事情，比如处理用户的输入或保持动画的流畅，它就必须等到渲染完成。</p><p>因此，我们将整个<code>render</code>任务分成一个个小单元，在完成每个单元后，如果还有别的需要做，我们会让浏览器打断渲染</p><p>我们使用<code>requestIdleCallback</code>来完成这一调度</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于<code>requestIdleCallback</code>，这里参考<a target="_blank" rel="noopener" href="https://juejin.im/post/5ad71f39f265da239f07e862">你应该知道的 requestIdleCallback</a>。</p></blockquote><blockquote><p>React 不再使用 <code>requestIdleCallback</code>了，原因见：<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/11171#issuecomment-417349573%E3%80%82">https://github.com/facebook/react/issues/11171#issuecomment-417349573。</a></p><p>现在它使用 scheduler：<a target="_blank" rel="noopener" href="https://github.com/facebook/react/tree/main/packages/scheduler%E3%80%82%E4%BD%86%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E7%94%A8%E4%BE%8B%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AE%83%E5%9C%A8%E6%A6%82%E5%BF%B5%E4%B8%8A%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82">https://github.com/facebook/react/tree/main/packages/scheduler。但对于这个用例来说，它在概念上是一样的。</a></p></blockquote><h2 id="Fibers"><a href="#Fibers" class="headerlink" title="Fibers"></a>Fibers</h2><p>为了组织每个工作单元，我们定义一个数据结构：fiber tree</p><p>每个<code>fiber</code>对应一个<code>element</code>，而且<code>fiber</code>也是一个工作单元</p><p>我们会在<code>render</code>方法里面设置<code>root fiber</code>，并且将其设置为<code>nextUnitOfWork</code>。而其余的工作将在<code>performUnitOfWork</code>函数里发生，在那里我们为每一个<code>fiber</code>做三件事</p><ol><li>将<code>elemenr</code>添加进<code>dom</code></li><li>在<code>element.children</code>里创建<code>fiber</code></li><li>选择下一个工作单元（这也是<code>fiber</code>结构的目的之一）</li></ol><p>现在我们用代码来实现</p><p>首先，需要调整<code>render</code>的代码，将创建<code>dom</code>的逻辑抽离，因为上面提到了我们将创建<code>dom</code>的工作交给 fiber 完成</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createDom</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dom = fiber.<span class="property">type</span> == <span class="string">&quot;TEXT_ELEMENT&quot;</span> ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>) : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(fiber.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt; key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(fiber.<span class="property">props</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = fiber.<span class="property">props</span>[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个新的全局变量<code>nextUnitOfWork</code>，并在<code>render</code>函数中将其设置为<code>root fiber</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>然后，当浏览器就绪时，会通过<code>requestIdleCallback</code>调用<code>workLoop</code>函数，我们将开始在<code>root fiber</code>工作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO add dom node</span></span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个新的节点并将其追加到<code>dom</code>中，并在<code>fiber.dom</code>中保持对节点的追踪</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">parent</span>) &#123;</span><br><span class="line">    fiber.<span class="property">parent</span>.<span class="property">dom</span>.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们为 children 创建 newFiber ：如果 newFiber 是第一个孩子，那么他是 child，其余都是 sibling</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">parent</span>) &#123;</span><br><span class="line">    fiber.<span class="property">parent</span>.<span class="property">dom</span>.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[i];</span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.<span class="property">type</span>,</span><br><span class="line">      <span class="attr">props</span>: elements.<span class="property">props</span>,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.<span class="property">child</span> = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们选择下一个工作单元，我们会按照以下优先级选择下一个 fiber</p><ul><li>在当前节点下寻找是否有子节点<ul><li>若有, 则进入子节点</li><li>若没有, 则在当前节点下寻找是否有下一个相邻节点<ul><li>若有, 则进入下一个相邻节点</li><li>若没有, 则返回它的父节点</li></ul></li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略前面的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.<span class="property">child</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Render-and-Commit-Phases"><a href="#Render-and-Commit-Phases" class="headerlink" title="Render and Commit Phases"></a>Render and Commit Phases</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOf</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略前面的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">parent</span>) &#123;</span><br><span class="line">    fiber.<span class="property">parent</span>.<span class="property">dom</span>.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们在对每个元素进行处理时，都会向<code>dom</code>添加一个新的节点</p><p>而且，由于使用<code>requestIdleCallback</code>进行调度的原因，在我们完成整棵树的渲染工作前，浏览器可能会中断我们的工作。</p><p>在这种情况下，用户会看到一个不完整的界面，这是我们不希望的</p><p>所以我们从将提交<code>DOM</code>的逻辑抽离，在完成整个树的渲染工作后再提交<code>DOM</code>（称为 Commit phases）</p><p>并且，我们将会追踪<code>fiber tree</code>的<code>root fiber</code>，称之为 work in progress root – <code>wipRoot</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>一旦我们完成所有工作，我们就将<code>fiber tree</code>提交给<code>DOM</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    <span class="comment">// 提交阶段</span></span><br><span class="line">    <span class="title function_">commitRoot</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>commitRoot</code>函数中，我们递归地向<code>DOM</code>中插入节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">commitWork</span>(wipRoot);</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.<span class="property">parent</span>.<span class="property">dom</span>;</span><br><span class="line">  domParent.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>); <span class="comment">// 我们只有向 DOM 添加节点，更新和删除呢？见下一节</span></span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h2><p>目前为止，我们只是向 DOM 中添加节点，但是更新和删除节点呢？</p><p>这就是我们接下来要做的，我们需要将在<code>render</code>函数收到的<code>elements</code>与提交给<code>dom</code>的最后一个<code>fiber tree</code>做比较</p><p>我们添加一个全局变量<code>currentRoot</code>，保存在完成<code>commit</code>阶段后提交到<code>dom</code>的最后一个<code>fiber tree</code>，并且在每一个<code>fiber</code>中添加<code>alternate</code>属性，指向前一个<code>commit</code>阶段的<code>fiber</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">commitWork</span>(wipRoot.<span class="property">child</span>);</span><br><span class="line">	currentRoot = wipRoot; <span class="comment">// 完成 commit 后保存引用</span></span><br><span class="line">	wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> domParent = fiber.<span class="property">parent</span>.<span class="property">dom</span>;</span><br><span class="line">	domParent.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">	<span class="title function_">commitWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">	<span class="title function_">commitWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">	wipRoot = &#123;</span><br><span class="line">		<span class="attr">dom</span>: container,</span><br><span class="line">		<span class="attr">props</span>: &#123;</span><br><span class="line">			<span class="attr">children</span>: [element],</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">alternate</span>: currentRoot, <span class="comment">// 上次 commit 的 fiber</span></span><br><span class="line">	&#125;;</span><br><span class="line">	nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>; <span class="comment">// 上次渲染的 fiber tree</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>然后我们对<code>performUnitOfWork</code>函数进行重构，添加一个<code>reconcileChildren</code>函数，对原先<code>create new fiber</code>的代码进行重构</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">		fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> elements = fiber.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">	<span class="title function_">reconcileChildren</span>(fiber, elements); <span class="comment">// reconcileChildren</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> fiber.<span class="property">child</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">	<span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nextFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nextFiber.<span class="property">sibling</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nextFiber = nextFiber.<span class="property">parent</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>reconcileChildren</code>函数中对比旧的<code>fiber</code>和新的<code>elements</code></p><p>我们同时迭代旧的<code>fiber</code>的子节点和新元素的子节点</p><p>我们先忽略同时迭代两者的逻辑，只关心最重要的东西：<code>oldFiber</code>和<code>element</code>。<code>element</code>是我们即将要渲染到 DOM 的东西，而<code>oldFiber</code>是上次渲染的内容</p><p>我们需要对它们进行比较，看看是否有任何需要应用于DOM的变化。</p><p>使用<code>type</code>来比较它们</p><ul><li>如果类型相同，我们保持旧<code>fiber</code>的引用，然后仅更新<code>props</code></li><li>如果类型不同、存在新<code>element</code>，意味着需要创建新的<code>dom</code>节点</li><li>如果类型不同、不存在新<code>element</code>、有旧<code>fiber</code>，意味着需要删除旧的<code>dom</code>节点</li></ul><blockquote><p>实际上，React 也是用了 key，这会让 diff 算法更准确。例如：它可以检测 children 的位置变化</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) &#123;</span><br><span class="line">	oldFiber = wipFiber.<span class="property">alternate</span> &amp;&amp; wipFiber.<span class="property">alternate</span>.<span class="property">child</span>;</span><br><span class="line">	<span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (index &lt; elements.<span class="property">length</span> || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> element = elements[index];</span><br><span class="line">		<span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.<span class="property">type</span> === oldFiber.<span class="property">type</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">			<span class="comment">// TODO update the node</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">			<span class="comment">// TODO add this node</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">			<span class="comment">// TODO delete the oldFiber&#x27;s node</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历 fiber</span></span><br><span class="line">		<span class="comment">// 因为 fiber 只有一个 child 节点，其余 child 节点被视作 child 节点的 sibling 节点。</span></span><br><span class="line">		<span class="comment">// 因此这样遍历</span></span><br><span class="line">		<span class="keyword">if</span> (oldFiber) oldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一个child才可以作为child，其他的就是sibling</span></span><br><span class="line">		<span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">			wipFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			prevSibling.<span class="property">sibling</span> = newFiber;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		prevSibling = newFiber;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当旧 fiber 和新元素有着相同的类型的时候，我们创建一个新 fiber，它保持旧 fiber 的 dom 节点</p><p>我们还为 fiber 添加了一个新属性：<code>effectTag</code>，我们将在后面的 commit phase 使用这个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update the node</span></span><br><span class="line"><span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">	newFiber = &#123;</span><br><span class="line">		<span class="attr">type</span>: oldFiber.<span class="property">type</span>,</span><br><span class="line">		<span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">		<span class="attr">dom</span>: oldFiber.<span class="property">dom</span>,</span><br><span class="line">		<span class="attr">parent</span>: wipFiber,</span><br><span class="line">		<span class="attr">alternate</span>: oldFiber,</span><br><span class="line">		<span class="attr">effectTag</span>: <span class="string">&quot;UPDATE&quot;</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于元素需要一个新的 dom 节点的情况，我们使用 <code>PLACEMENT</code>的<code>effectTag</code>来标记他</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add the node</span></span><br><span class="line"><span class="keyword">if</span> (!sameType &amp;&amp; element) &#123;</span><br><span class="line">	newFiber = &#123;</span><br><span class="line">		<span class="attr">type</span>: element.<span class="property">type</span>,</span><br><span class="line">		<span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">		<span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">		<span class="attr">parent</span>: wipFiber,</span><br><span class="line">		<span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">		<span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于需要删除节点的情况，由于我们没有新的元素，所以把<code>effectTag</code>加在旧 fiber 上</p><p>但是当我们将 fiber tree 提交到 dom 时，我们将会从 work in progress root (wipRoot) 开始，那里没有旧 fiber</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!sameType &amp;&amp; oldFiber) &#123;</span><br><span class="line">	oldFiber.<span class="property">effectTag</span> = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">	deletions.<span class="title function_">push</span>(oldFiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们添加一个全局变量<code>deletions</code>来记录要删除的 fiber</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">	wipRoot = &#123;</span><br><span class="line">		<span class="attr">dom</span>: container,</span><br><span class="line">		<span class="attr">props</span>: &#123;</span><br><span class="line">			<span class="attr">children</span>: [element],</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">alternate</span>: currentRoot,</span><br><span class="line">	&#125;;</span><br><span class="line">	deletions = [];</span><br><span class="line">	nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>; <span class="comment">// 记录要删除的 fiber</span></span><br></pre></td></tr></table></figure><p>然后，当我们向 dom 提交变化的时候，会使用 <code>deletions</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">  deletions.<span class="title function_">forEach</span>(commitWork)</span><br><span class="line">  <span class="title function_">commitWork</span>(wipRoot.<span class="property">child</span>)</span><br><span class="line">  currentRoot = wipRoot</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们在<code>commitWork</code>函数中添加处理<code>effectTag</code>的逻辑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> domParent = fiber.<span class="property">parent</span>.<span class="property">dom</span>;</span><br><span class="line">	<span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.<span class="property">dom</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">		domParent.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.<span class="property">dom</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="title function_">updateDom</span>(fiber.<span class="property">dom</span>, fiber.<span class="property">alternate</span>.<span class="property">props</span>, fiber.<span class="property">props</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">		domParent.<span class="title function_">removeChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">commitWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">	<span class="title function_">commitWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>UPDATE</code>的时候，我们需要删除已经消失的属性、并且设置新增或者修改的属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">isEvent</span> = key =&gt; key.<span class="title function_">startsWith</span>(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">	<span class="comment">// 删除已经没有的props</span></span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">keys</span>(prevProps)</span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key != <span class="string">&quot;children&quot;</span> &amp;&amp; !<span class="title function_">isEvent</span>(key))</span><br><span class="line">		<span class="comment">// 不在nextProps中</span></span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> !key <span class="keyword">in</span> nextProps)</span><br><span class="line">		.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 清空属性</span></span><br><span class="line">			dom[key] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新增的属性/修改变化的属性</span></span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps)</span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !<span class="title function_">isEvent</span>(key))</span><br><span class="line">		<span class="comment">// 不再prevProps中</span></span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> !key <span class="keyword">in</span> prevProps || prevProps[key] !== nextProps[key])</span><br><span class="line">		.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">			dom[key] = nextProps[key];</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除事件处理函数</span></span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">keys</span>(prevProps)</span><br><span class="line">		.<span class="title function_">filter</span>(isEvent)</span><br><span class="line">		<span class="comment">// 新的属性没有，或者有变化</span></span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> !key <span class="keyword">in</span> nextProps || prevProps[key] !== nextProps[key])</span><br><span class="line">		.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> eventType = key.<span class="title function_">toLowerCase</span>().<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">			dom.<span class="title function_">removeEventListener</span>(eventType, prevProps[key]);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的事件处理函数</span></span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps)</span><br><span class="line">		.<span class="title function_">filter</span>(isEvent)</span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> prevProps[key] !== nextProps[key])</span><br><span class="line">		.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> eventType = key.<span class="title function_">toLowerCase</span>().<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">			dom.<span class="title function_">addEventListener</span>(eventType, nextProps[key]);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function-Components"><a href="#Function-Components" class="headerlink" title="Function Components"></a>Function Components</h2><p>接下来我们添加对函数式组件的支持</p><p><strong>函数式组件相当于包裹了函数的 jsx 元素</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>首先我们将这段 jsx 代码转换成 js 的形式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Didact</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hi &quot;</span>, props.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">Didact</span>.<span class="title function_">createElement</span>(<span class="title class_">App</span>, &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Function components 有两点不同</p><ol><li>来自函数式组件的 fiber 没有 dom 节点（缺少和 dom 类型对应的 fiber.type 字段，因为 fiber.type 实际是一个函数）</li><li><code>children</code>来自于运行中的函数而不是<code>props</code></li></ol><p>因此，我们在<code>performUnitOfWork</code>函数中检查 fiber 是否是一个函数，根据这一点，我们选择不同的更新函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据 fiber.type 决定不同的更新函数</span></span><br><span class="line">	<span class="keyword">const</span> isFunctionComponent = fiber.<span class="property">type</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>;</span><br><span class="line">	<span class="keyword">if</span> (isFunctionComponent) <span class="title function_">updateFunctionComponent</span>(fiber);</span><br><span class="line">	<span class="keyword">else</span> <span class="title function_">updateHostComponent</span>(fiber);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......rest code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>updateHostCompenent</code>函数中我们的做法与之前一样</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateHostComponent</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">	<span class="comment">// add dom node</span></span><br><span class="line">	<span class="keyword">if</span> (!fiber.<span class="property">dom</span>) fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新建 newFiber，构建 fiber tree</span></span><br><span class="line">	<span class="title function_">reconcileChildren</span>(fiber, fiber.<span class="property">props</span>.<span class="property">children</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在<code>updateFunctionComponent</code>函数中获取<code>children</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">	<span class="comment">// 这里 fiber.type 是一个函数</span></span><br><span class="line">	<span class="keyword">const</span> children = [fiber.<span class="title function_">type</span>(fiber.<span class="property">props</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新建 newFiber，构建 fiber tree</span></span><br><span class="line">	<span class="title function_">reconcileChildren</span>(fiber, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用之前的例子解释一下上面这段代码，<code>fiber.type</code>相当于<code>App</code> function，当我们调用它的时候会返回<code>h1</code>元素</p><p>然后，一旦有了<code>children</code>，<code>reconciliation</code>函数也能同样运作，所以我们不需要改变什么</p><p>我们还需要改造<code>commitWork</code>函数</p><p>由于存在没有<code>dom</code>节点的 fiber，我们需要改变两点</p><p>首先，<code>const domParent = fiber.parent.dom</code>这段代码不再可靠——因为函数式组件没有 dom。所以，为了找到<code>dom</code>节点的父节点，我们需要遍历 fiber tree 直到找到一个带有 dom 的 fiber</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 由于函数式组件没有 dom 的原因，所以需要不断向上遍历找到含有 dom 的 fiber</span></span><br><span class="line">	<span class="keyword">let</span> domParentFiber = fiber.<span class="property">parent</span>;</span><br><span class="line">	<span class="keyword">while</span> (!domParentFiber.<span class="property">dom</span>) &#123;</span><br><span class="line">		domParentFiber = domParentFiber.<span class="property">parent</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> domParent = domParentFiber.<span class="property">dom</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，当我们移除 dom 节点的时候，也需要递归地遍历 fiber 来找到有 dom 节点的子节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">dom</span> &amp;&amp; fiber.<span class="property">effectTag</span> === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">		<span class="title function_">commitDeletion</span>(fiber, domParent);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitDeletion</span>(<span class="params">fiber, domParent</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">		domParent.<span class="title function_">removeChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_">commitDeletion</span>(fiber.<span class="property">child</span>, domParent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/React/" rel="tag"># React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/18/TypeScript%20%E4%B8%8E%E9%9B%86%E5%90%88%E8%AE%BA/" rel="prev" title="TypeScript 与集合论"><i class="fa fa-chevron-left"></i> TypeScript 与集合论</a></div><div class="post-nav-item"><a href="/2023/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20http%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95/" rel="next" title="深入了解 http 协议">深入了解 http 协议<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Latte</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://l1atte.github.io/2023/02/15/Build%20your%20own%20React/"}</script><script src="/js/third-party/quicklink.js"></script></body></html>